---
layout: post
title:  "Data Structure Study"
date:   2018-01-22 16:00:00 +0900
tag: [Data Structure]
---

# 1. BASIC CONCEPTS

## System Life Cycle

1. Requirements
2. Analysis
3. Design
4. Refinement and coding
5. Verification
  - Correctness proofs
  - Testing
  - Error removal

## Pointers And Dynamic Memory Allocation

### Pointers

  - `&` the address operator
  - `*` the dereferencing (or indirection) operator

  ```
  int i,  *pi;
  pi = &i;

  i = 10;
  *pi = 10;

  if (pi == NULL)

  if (!pi)
  ```

### Dynamic Memory Allocation

```
int i, *pi;
float f, *pf;
pi = (int *) malloc(sizeof(int));
pf = (float *) malloc(sizeof(float));

*pi = 1024;
*pf = 3.14;
printf("an integer = %d, a float = %f\n", *pi, *pf);
free(pi);
free(pf);

#define MALLOC(p, s) if (!((p) == malloc(s))) { fprintf(stderr, "Insufficient memory"); exit(EXIT_FAILURE); }

MALLOC(pi, sizeof(int));
MALLOC(pf, sizeof(float));

```
  - dangling reference

### Algorithm Specification

#### Definition
  - An algorithm is a finite set of instructions that, if followed, accomplishes a particular task. In addition, all algorithms must satisfy the following criteria:
  1. Input : There are zero or more quantities that are externally supplied.
  2. Output : At least one quantity is produced.
  3. Definiteness : Each instruction is clear and unambiguous
  4. Finiteness : If we trace out the instructions of an algorithm, then for all cases, the algorithm terminates after a finite number of steps.
  5. Effectiveness : it also must be feasible.

## Asymptotic Notation (O, Ω, Θ)

- Definition : [Big "oh"] f(_n_) = O(g(_n_)) (read as "_f_ of _n_ is big oh of _g_ of _n_") if and only if there exist positive constants _c_ and _n_<sub>0</sub> such that f(_n_) <= cg(_n_) for all _n_, _n_ >= _n_<sub>0</sub>.

- Definition : [Omega] f(_n_) = Ω(g(_n_)) (read as "_f_ of _n_ is omega of g of _n_") if and only if there exist positive constants c and n<sub>0</sub> such that f(_n_) >= cg(_n_) for all _n_, _n_ >= _n_<sub>0</sub>.

- Definition : [Theta] f(_n_) = Θ(g(_n_)) (read as "_f_ of _n_ is theta of g of _n_") if and only if there exist positive constants c<sub>1</sub>, c<sub>2</sub>, and _n_ 0 such that c<sub>1</sub>g(_n_) <= f(_n_) <= c<sub>2</sub>g(_n_) for all _n_, _n_ >= _n_<sub>0</sub>.
