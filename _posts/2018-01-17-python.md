---
layout: post
title:  "Python study"
date:   2018-01-17 15:00:00 +0900
tags: [Python]
---

# Python Study

- [tutorials](https://docs.python.org/3/tutorial/index.html)
- [Built in functions](https://docs.python.org/3/library/functions.html)
- [The Python Standard Library](https://docs.python.org/3.6/library/index.html)

## 여러개의 입력값을 받을 때

```

def sum_many(*args): # 입력값들을 튜플로 만듬
    sum = 0
    for i in args:
        sum = sum + i
    return sum

sum_many(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

55
```

---

## 키워드 파라미터 kwargs (keyword arguments)
> key=value 형식의 파라미터를 넘겨주면 kwargs 에 저장된다.

```
def func(**kwargs):
    print(kwargs)

func(a=1, b=2)
```

---

## 함수 인자에 초기값 설정, (defaults parameter는 맨 마지막 arguments로)

```
def log_in(ids, pw, admin = True):
    print(admin)
    print(ids, pw)
```


---

## global # not recommended

```
a = 1
def vartest():
    global a
    a = a+1

vartest()
print(a)
```

---

## print

```
print("life" "is" "too short")
lifeistoo short

print("life"+"is"+"too short")
lifeistoo short

print("life", "is", "too short")
life is too short
```

---

## Reading and Writing Files
> `open()` returns a file object, and is most commonly used with two arguments: `open(filename, mode)`.
> file object - (raw binary files, buffered binary files and text files.)
> It is good practice to use the `with` keyword when dealing with file objects. The advantage is that the file is properly closed after its suite finishes, even if an exception is raised at some point. Using `with` is also much shorter than writing equivalent try-finally blocks:
> f.seek(offset, from_what)

```
>>> f = open('workfile', 'r')
>>> with open('workfile') as f:
...     read_data = f.read()
>>> f.closed
True
```

---

## Classes

```
class MyClass:
    """A simple example class"""
    i = 12345

    def f(self):
        return 'hello world'

x = MyClass()
m.__doc__

x.counter = 1
while x.counter < 10:
    x.counter = x.counter * 2
print(x.counter)
del x.counter # delete x.counter

#######

class Dog:

    def __init__(self, name):
        self.name = name
        self.tricks = []    # creates a new empty list for each dog

    def add_trick(self, trick):
        self.tricks.append(trick)

>>> d = Dog('Fido')
>>> e = Dog('Buddy')
>>> d.add_trick('roll over')
>>> e.add_trick('play dead')
>>> d.tricks
['roll over']
>>> e.tricks
['play dead']

# Empty class
class Employee:
    pass
```

---

## Inheritance

```
class DerivedClassName(BaseClassName):
    <statement-1>
    .
    .
    .
    <statement-N>

```

---

## Iterators
>This style of access is clear, concise, and convenient. The use of iterators pervades and unifies Python.
> Behind the scenes, the for statement calls `iter()` on the container object. The function returns an iterator object that defines the method `__next__()` which accesses elements in the container one at a time. When there are no more elements, `__next__()` raises a `StopIteration exception` which tells the for loop to terminate. You can call the `__next__()` method using the `next()` built-in function.

```
class Reverse:
    """Iterator for looping over a sequence backwards."""
    def __init__(self, data):
        self.data = data
        self.index = len(data)

    def __iter__(self):
        return self

    def __next__(self):
        if self.index == 0:
            raise StopIteration
        self.index = self.index - 1
        return self.data[self.index]

>>> rev = Reverse('spam')
>>> iter(rev)
<__main__.Reverse object at 0x00A1DB50>
>>> for char in rev:
...     print(char)
...
m
a
p
s
```

---

## Generators
>Generators are a simple and powerful tool for creating iterators. They are written like regular functions but use the `yield` statement whenever they want to return data. Each time `next()` is called on it, the generator resumes where it left off (it remembers all the data values and which statement was last executed). An example shows that generators can be trivially easy to create:

```

def reverse(data):
    for index in range(len(data)-1, -1, -1):
        yield data[index]

>>> for char in reverse('golf'):
...     print(char)
...
f
l
o
g

#
>>> gen_exp = (x ** 2 for x in range(10) if x % 2 == 0)
>>> for x in gen_exp:
...     print(x)
0  
4  
16  
36  
64

```

---

## Python List Comprehension vs Generator Expressions

> advantage **Generator Expressionsof** is use of less memory
```
>>> from sys import getsizeof
>>> my_comp = [x * 5 for x in range(1000)]
>>> my_gen = (x * 5 for x in range(1000))
>>> getsizeof(my_comp)
9024  
>>> getsizeof(my_gen)
88
```

>The generator yields one item at a time — thus it is more memory efficient than a list.
